;* Yggdrasil (TM) Core Operating System (MCS-51): FIFO Library
;* Copyright (C) DeRemee Systems, IXE Electronics LLC
;* Portions copyright IXE Electronics LLC, Republic Robotics, FemtoLaunch, FemtoSat, FemtoTrack, Weland
;* This work is made available under the Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.
;* To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/4.0/.

$INCLUDE (System.INC)

#include "FIFO.inc"
#include "Return_Codes_FIFO.inc"

EXTRN	CODE	(DPTRBADD, DPTRWADDAB, DPTRBGMRDONA, DPTRBGMRDONO, DPTRBGMRDONX, DPTRBLRXDON, DPTRBSRXDON, DPTRWLDXDNN, DPTRWLDXDON, DPTRWLRXDON, DPTRWSXRDNN, DPTRWSXRDON)
EXTRN	CODE	(DPTRBAMRDONA, DPTRBARMDONS, DPTRBGRMDONX)
EXTRN	CODE	(MEMALCXRAM, MEMFREEXRAM)
EXTRN	CODE	(TASKCURR)

PUBLIC	LFIFOINIT, LFIFODELETE, LFIFOCREATE, LFIFOISEMPTY, LFIFOISFULL, LFIFOREADBYTE, LFIFOREADSTR, LFIFORESET, LFIFOWRITEBYTE, LFIFOWRITESTR

FIFO_ROUTINES	SEGMENT		CODE

RSEG	FIFO_ROUTINES


	;* - INDICATES FUNCTIONS AVAILABLE TO USER PROGRAMS


	;*DELETES THE SPECIFIED FIFO
	;ON ENTRY:
	;	R0	= FIFO ID
	;ON RETURN:
	;	R0	= VALUE ON ENTRY
	;	C	= 0 IF SUCCESS
	;		A	= 0x00
	;	C	= 1 IF ERROR
	;		A	= ERROR CODE
	LFIFODELETE	PROC
			;SAVE REGISTERS
			PUSH	B
			PUSH	DPL
			PUSH	DPH
			;GET FIFO'S FCB ADDRESS
			CALL	FIFOFCBADDR
			JNC		LFIFODELETEC
			;ERROR - COULD NOT GET FIFO'S FCB ADDRESS
		LFIFODELETEA:
			SETB	C
		LFIFODELETEB:
			;RESTORE REGISTERS & RETURN
			POP		DPH
			POP		DPL
			POP		B
			RET
		LFIFODELETEC:
			;DISABLE INTERRUPTS
			PUSH	IE
			CLR		EA
			;ENSURE FIFO NOT BUSY
			MOV		B, #FIFO_ENTRY_OFFS_FLAGS
			CALL	DPTRBLRXDON
			JNB		FIFO_BIT_BUSY, LFIFODELETED
			;ERROR - FIFO BUSY
			MOV		A, #FIFO_ERR_FIFO_BUSY
			SJMP	LFIFODELETEA
		LFIFODELETED:
			;SET FIFO'S BUSY BIT
			SETB	FIFO_BIT_BUSY
			CALL	DPTRBSRXDON
			;RESTORE INTERRUPTS
			POP		IE
			;
			MOV		A, R0
			PUSH	ACC
			;LOAD FIFO'S BASE ADDRESS & BANK
			MOV		B, #FIFO_ENTRY_OFFS_BASE_ADDR_LSB
			CALL	DPTRWLRXDON
			MOV		B, #FIFO_ENTRY_OFFS_BANK
			CALL	DPTRBLRXDON
			;FREE FIFO'S MEMORY
			CALL	MEMFREEXRAM
			POP		ACC
			MOV		R0, A
			JNC		LFIFODELETEE
			;ERROR - COULD NOT FREE FIFO'S MEMORY
			MOV		A, #FIFO_ERR_FIFO_MEM_RELSE
			SJMP	LFIFODELETEA
		LFIFODELETEE:
			;DISABLE INTERRUPTS
			PUSH	IE
			CLR		EA
			;CLEAR FIFO'S PRESENT & BUSY BITS
			CLR		A
			CALL	DPTRBSRXDON
			;RESTORE INTERRUPTS
			POP		IE
			;
			CLR		C
			SJMP	LFIFODELETEB
	ENDP


	;RETURNS THE SPECIFIED FIFO'S FCB ADDRESS
	;ON ENTRY:
	;	R0	= FIFO ID
	;ON RETURN:
	;	C	= 0 IF SUCCESS
	;		A			= 0x00
	;		DPTR	= FCB ADDRESS
	;	C	= 1 IF FAIL
	;		A			= ERROR CODE
	;		DPTR	= 0x0000
	FIFOFCBADDR	PROC
			;SAVE REGISTERS
			MOV		A, R1
			PUSH	ACC
			MOV		A, R2
			PUSH	ACC
			PUSH	B
			;LOAD FCB ADDRESS
			MOV		DPTR, #FIFO_ADR
			CALL	DPTRWLDXDNN
			;LOAD FIFO ENTRY SIZE
			MOV		B, #FIFO_FCB_OFFS_ENTRY_SIZE
			CALL	DPTRBLRXDON
			MOV		R1, A
			;LOAD FIFO ENTRY COUNT
			MOV		B, #FIFO_FCB_OFFS_FIFO_COUNT
			CALL	DPTRBLRXDON
			MOV		R2, A
			;POINT TO FIRST FIFO TABLE ENTRY
			MOV		A, #FIFO_FCB_OFFS_ENTRY_0
		FIFOFCBADDRA:
			CALL	DPTRBADD
			;LOAD FIFO ENTRY'S FLAGS
			MOV		B, #FIFO_ENTRY_OFFS_FLAGS
			CALL	DPTRBLRXDON
			JB		FIFO_BIT_PRESENT, FIFOFCBADDRD
		FIFOFCBADDRB:
			;PROCESS NEXT ENTRY IF NOT LAST
			MOV		A, R1
			DJNZ	R2, FIFOFCBADDRA
			;ERROR - FIFO ID NOT FOUND
			MOV		R1, #FIFO_ERR_FIFO_INV_ID
			SETB	C
		FIFOFCBADDRC:
			;RESTORE REGISTERS & RETURN
			POP		B
			POP		ACC
			MOV		R2, A
			POP		ACC
			XCH		A, R1
			RET
		FIFOFCBADDRD:
			;LOAD FIFO ENTRY'S ID
			MOV		B, #FIFO_ENTRY_OFFS_ID
			CALL	DPTRBLRXDON
			;ENTRY ID == FIFO ID?
			XRL		A, R0
			JNZ		FIFOFCBADDRB
			;ENTRY FOUND
			CLR		C
			SJMP	FIFOFCBADDRC
	ENDP


	;*INITIALIZES THE FIFO LIBRARY
	;ON ENTRY:
	;	NONE
	;ON RETURN:
	;	C	= 0 IF SUCCESS
	;	C	= 1 IF FAIL
	LFIFOINIT:
		;CALCULATE REQUIRED MEMORY
		MOV		A, #FIFO_ENTRY_SIZE
		MOV		B, #FIFO_ENTRY_MAX_COUNT
		MUL		AB
		MOV		R1, B
		ADD		A, #FIFO_FCB_SIZE
		MOV		R0, A
		CLR		A
		ADDC	A, R1
		MOV		R1, A
		;ALLOCATE MEMORY
		CALL MEMALCXRAM
		JNC FIFOINITB
		;RETURN WITH "NO FREE MEMORY" ERROR
		MOV		A, #SYS_ERR_NO_MEM
		SETB	C
		RET
	FIFOINITB:
		;STORE FIFO CONTROL BLOCK BASE ADDRESS
		MOV		DPTR, #FIFO_ADR
		CALL	DPTRWSXRDNN
		;
		MOV		DPL, R0
		MOV		DPH, R1
		;STORE FLAGS
		CLR		A
		MOV		B, #FIFO_FCB_OFFS_FLAGS
		CALL	DPTRBSRXDON
		;STORE ENTRY SIZE
		MOV		A, #FIFO_ENTRY_SIZE
		MOV		B, #FIFO_FCB_OFFS_ENTRY_SIZE
		CALL	DPTRBSRXDON
		;STORE MAXIMUM FIFO COUNT
		MOV		A, #FIFO_ENTRY_MAX_COUNT
		MOV		B, #FIFO_FCB_OFFS_MAX_FIFOS
		CALL	DPTRBSRXDON
		;STORE FIFO COUNT
		CLR		A
		MOV		B, #FIFO_FCB_OFFS_FIFO_COUNT
		CALL	DPTRBSRXDON
		;
		CLR		C
		RET


	;*RETURNS TRUE IF THE SPECIFIED FIFO IS EMPTY
	;ON ENTRY:
	;	R0	= FIFO ID
	;ON RETURN:
	;	R0	= VALUE ON ENTRY
	;	C	= 0
	;		A	= 0x00 IF NOT EMPTY
	;	C	= 1
	;		A	= 0xFF IF EMPTY
	;		A	!= 0xFF IF ERROR
	LFIFOISEMPTY	PROC
			;SAVE REGISTERS
			PUSH	B
			PUSH	DPL
			PUSH	DPH
			;GET FIFO'S FCB ADDRESS
			CALL	FIFOFCBADDR
			JNC		LFIFOISEMPTYB
			;ERROR - COULD NOT GET FIFO'S FCB ADDRESS
		LFIFOISEMPTYA:
			;RESTORE REGISTERS & RETURN
			POP		DPH
			POP		DPL
			POP		B
			RET
		LFIFOISEMPTYB:
			;LOAD FLAGS
			MOV		B, #FIFO_ENTRY_OFFS_FLAGS
			CALL	DPTRBLRXDON
			MOV		C, FIFO_BIT_EMPTY
			CLR		A
			JNC		LFIFOISEMPTYA
			CPL		A
			SJMP	LFIFOISEMPTYA
	ENDP

	;*RETURNS TRUE IF THE SPECIFIED FIFO IS FULL
	;ON ENTRY:
	;	R0	= FIFO ID
	;ON RETURN:
	;	R0	= VALUE ON ENTRY
	;	C	= 0
	;		A	= 0x00 IF NOT FULL
	;	C	= 1
	;		A	= 0xFF IF FULL
	;		A	!= 0xFF IF ERROR
	LFIFOISFULL	PROC
			;SAVE REGISTERS
			PUSH	B
			PUSH	DPL
			PUSH	DPH
			;GET FIFO'S FCB ADDRESS
			CALL	FIFOFCBADDR
			JNC		LFIFOISFULLB
			;ERROR - COULD NOT GET FIFO'S FCB ADDRESS
		LFIFOISFULLA:
			;RESTORE REGISTERS & RETURN
			POP		DPH
			POP		DPL
			POP		B
			RET
		LFIFOISFULLB:
			;LOAD FLAGS
			MOV		B, #FIFO_ENTRY_OFFS_FLAGS
			CALL	DPTRBLRXDON
			MOV		C, FIFO_BIT_FULL
			CLR		A
			JNC		LFIFOISFULLA
			CPL		A
			SJMP	LFIFOISFULLA
	ENDP

	;*CREATES A NEW FIFO
	;ON ENTRY:
	;	R0 = FIFO SIZE, IN BYTES (0x00 = 256)
	;ON RETURN:
	;	C = 0 IF SUCCESS
	;		A		= 0x00
	;		R0	= FIFO ID
	;	C = 1 IF FAIL
	;		A = ERROR CODE
	;		R0	= 0x00
	LFIFOCREATE	PROC
			;SAVE REGISTERS
			MOV		A, R1
			PUSH	ACC
			MOV		A, R2
			PUSH	ACC
			PUSH	B
			;LOAD FCB ADDRESS
			MOV		DPTR, #FIFO_ADR
			CALL	DPTRWLDXDNN
			;LOAD FIFO ENTRY SIZE
			MOV		B, #FIFO_FCB_OFFS_ENTRY_SIZE
			CALL	DPTRBLRXDON
			MOV		R1, A
			;LOAD FIFO ENTRY COUNT
			MOV		B, #FIFO_FCB_OFFS_MAX_FIFOS
			CALL	DPTRBLRXDON
			MOV		R2, A
			;POINT TO FIRST FIFO TABLE ENTRY
			MOV		A, #FIFO_FCB_OFFS_ENTRY_0
		FIFOCREATEA:
			CALL	DPTRBADD
			;DISABLE INTERRUPTS
			PUSH	IE
			CLR		EA
			;LOAD FIFO ENTRY'S FLAGS
			MOV		B, #FIFO_ENTRY_OFFS_FLAGS
			CALL	DPTRBLRXDON
			JNB		FIFO_BIT_PRESENT, FIFOCREATED
		FIFOCREATEB:
			;PROCESS NEXT ENTRY IF NOT LAST
			POP		IE
			MOV		A, R1
			DJNZ	R2, FIFOCREATEA
			;ERROR - FIFO ID NOT FOUND
			MOV		R0, #0x00
			MOV		R1, #FIFO_ERR_FIFO_INV_ID
			SETB	C
		FIFOCREATEC:
			;RESTORE REGISTERS & RETURN
			POP		ACC
			MOV		R2, A
			POP		ACC
			XCH		A, R1
			POP		B
			RET
		FIFOCREATED:
			;EMPTY ENTRY FOUND, ALLOCATE RAM
			MOV		A, R0
			PUSH	ACC
			MOV		R1, #0x00
			CALL	MEMALCXRAM
			JNC		FIFOCREATEE
			;ERROR - COULD NOT ALLOCATE MEMORY
			POP		ACC
			MOV		R0, #0x00
			POP		IE
			MOV		R1, #FIFO_ERR_FIFO_MEM_ALLOC
			SJMP	FIFOCREATEC
		FIFOCREATEE:
			;SAVE BASE ADDRESS & BANK NUMBER
			MOV		B, #FIFO_ENTRY_OFFS_BASE_ADDR_LSB
			CALL	DPTRWSXRDON
			MOV		B, #FIFO_ENTRY_OFFS_BANK
			MOV		A, R0
			CALL	DPTRBSRXDON
			POP		ACC
			MOV		R0, A
			;STORE ENTRY'S SIZE
			MOV		B, #FIFO_ENTRY_OFFS_SIZE
			CALL	DPTRBSRXDON
			;SET ENTRY'S PRESENT & EMPTY FLAGS
			MOV		A, #(FIFO_FLAG_PRESENT OR FIFO_FLAG_EMPTY)
			MOV		B, #FIFO_ENTRY_OFFS_FLAGS
			CALL	DPTRBSRXDON
			;CALCULATE FIFO'S ID
			MOV		B, #FIFO_FCB_OFFS_MAX_FIFOS
			CALL	DPTRBLRXDON
			XCH		A, R2
			CLR		C
			SUBB	A, R2
			MOV		R0, A
			;STORE FIFO'S ID
			MOV		B, #FIFO_ENTRY_OFFS_ID
			CALL	DPTRBSRXDON
			;
			POP		IE
			CLR		C
			SJMP	FIFOCREATEC
	ENDP


	;READS FROM THE FIFO
	;ON ENTRY:
	;	R0		= FIFO ID
	;ON RETURN:
	;	C	= 0 IF SUCCESS
	;		A		= 0x00
	;		R1	= READ VALUE
	;	C	= 1 IF ERROR
	;		A		= ERROR CODE
	;		R1	= 0x00
	FIFOREAD	PROC
			;SAVE REGISTERS
			PUSH	B
			PUSH	DPL
			PUSH	DPH
			;GET FIFO'S FCB ADDRESS
			CALL	FIFOFCBADDR
			JNC		FIFOREADC
			;ERRROR - COULD NOT GET FIFO'S FCB ADDRESS
		FIFOREADA:
			MOV		R1, #0x00
			SETB	C
		FIFOREADB:
			;RESTORE REGISTERS & RETURN
			POP		DPH
			POP		DPL
			POP		B
			RET
		FIFOREADC:
			;DISABLE INTERRUPTS
			PUSH	IE
			CLR		EA
			;LOAD ENTRY'S FLAGS
			MOV		B, #FIFO_ENTRY_OFFS_FLAGS
			CALL	DPTRBLRXDON
			;ENSURE FIFO IS NOT BUSY
			JNB		FIFO_BIT_BUSY, FIFOREADF
			POP		IE
			MOV		A, #FIFO_ERR_FIFO_BUSY
			SJMP	FIFOREADA
		FIFOREADF:
			;ENSURE FIFO IS NOT EMPTY
			JNB		FIFO_BIT_EMPTY, FIFOREADG
			POP		IE
			MOV		A, #FIFO_ERR_FIFO_EMPTY
			SJMP	FIFOREADA
		FIFOREADG:
			;MARK FIFO AS BUSY
			SETB	FIFO_BIT_BUSY
			CALL	DPTRBSRXDON
			;RESTORE INTERRUPT ENABLE
			POP		IE
			;SAVE FIFO ENTRY'S CSB ADDRESS
			PUSH	DPL
			PUSH	DPH
			;LOAD READ INDEX
			MOV		B, #FIFO_ENTRY_OFFS_READ_INDEX
			CALL	DPTRBLRXDON
			;LOAD BASE ADDRESS
			MOV		B, #FIFO_ENTRY_OFFS_BASE_ADDR_LSB
			CALL	DPTRWLDXDON
			;CALCULATE FIFO READ ADDRESS
			CALL	DPTRBADD
			;READ BYTE FROM FIFO
			MOVX	A, @DPTR
			MOV		R1, A
			;RESTORE FIFO ENTRY'S CSB ADDRESS
			POP		DPH
			POP		DPL
			;INCREMENT READ INDEX
			MOV		B, #FIFO_ENTRY_OFFS_READ_INDEX
			CALL	DPTRBLRXDON
			INC		A
			PUSH	ACC
			;DETERMINE IF FIFO INDEX HAS WRAPPED AROUND
			MOV		B, #FIFO_ENTRY_OFFS_SIZE
			CALL	DPTRBLRXDON
			DEC		A
			POP		B
			CLR		C
			SUBB	A, B
			MOV		A, B
			JNC		FIFOREADH
			;ZEROIZE READ INDEX
			CLR		A
		FIFOREADH:
			;SAVE READ INDEX
			MOV		B, #FIFO_ENTRY_OFFS_READ_INDEX
			CALL	DPTRBSRXDON
			;DETERMINE IF FIFO FULL
			PUSH	ACC
			MOV		B, #FIFO_ENTRY_OFFS_WRITE_INDEX
			CALL	DPTRBLRXDON
			POP		B
			XRL		A, B
			MOV		B, #0x00
			JNZ		FIFOREADI
			;FIFO IS EMPTY
			MOV		B, #FIFO_FLAG_EMPTY
		FIFOREADI:
			PUSH	B
			;LOAD FIFO'S FLAGS
			MOV		B, #FIFO_ENTRY_OFFS_FLAGS
			CALL	DPTRBLRXDON
			;INSERT STATE OF EMPTY FLAG
			POP		B
			ORL		A, B
			;CLEAR FIFO'S FULL & BUSY FLAGS
			ANL		A, #((FIFO_FLAG_FULL XOR 0xFF) AND (FIFO_FLAG_BUSY XOR 0xFF))
			MOV		B, #FIFO_ENTRY_OFFS_FLAGS
			CALL	DPTRBSRXDON
			;
			CLR		A
			CLR		C
			;RESTORE REGISTERS & RETURN
			POP		DPH
			POP		DPL
			POP		B
			RET
	ENDP


	;*READS A BYTE FROM THE SPECIFIED FIFO
	;ON ENTRY:
	;	R0	= FIFO ID
	;ON RETURN:
	;	R0	= VALUE ON ENTRY
	;	C = 0 IF SUCCESS
	;		A		= 0x00
	;		R1	= READ VALUE
	;	C = 1 IF FAIL
	;		A		= ERROR CODE
	;		R0	= 0x00
	LFIFOREADBYTE	PROC
			CALL	FIFOREAD
			RET
	ENDP


	;*READS A STRING TO THE SPECIFIED FIFO
	;READS AS MANY BYTES FROM THE FIFO AS IT CAN BEFORE RETURNING WITH ERROR
	;ON ENTRY:
	;	R0		= FIFO ID
	;	R2:R1	= STRING POINTER
	;	R3		= TERMINATOR
	;ON RETURN:
	;	R0	= VALUE ON ENTRY
	;	C = 0 IF SUCCESS
	;		A = 0x00
	;		R2:R1	= ADDRESS OF STRING'S TERMINATOR
	;	C = 1 IF FAIL
	;		A = ERROR CODE
	;		R2:R1	= ADDRESS OF NEXT UNWRITTEN CHARACTER
	LFIFOREADSTR	PROC
			;SAVE REGISTERS
			PUSH	B
			PUSH	DPL
			PUSH	DPH
			;
			MOV		DPL, R1
			MOV		DPH, R2
			MOV		B, R3
		LFIFOREADSTRA:
			MOV		A, R1
			PUSH	ACC
			;READ CHARACTER FROM FIFO
			CALL	FIFOREAD
			MOV		A, R1
			POP		ACC
			XCH		A, R1
			JC		LFIFOREADSTRB
			;STORE CHARACTER
			MOVX	@DPTR, A
			;CHARACTER == TERMINATOR
			CJNE	A, B, LFIFOREADSTRC
			;DONE
			CLR		A
			CLR		C
		LFIFOREADSTRB:
			;RESTORE REGISTERS & RETURN
			MOV		R1, DPL
			MOV		R2, DPH
			POP		DPH
			POP		DPL
			POP		B
			RET
		LFIFOREADSTRC:
			;PROCESS NEXT CHARACTER
			INC		DPTR
			SJMP	LFIFOREADSTRA
	ENDP


	;*RESETS THE SPECIFIED FIFO'S READ AND WRITE INDEXES,
	;CLEARS THE FULL FLAG, AND SETS THE EMPTY FLAG
	;ON ENTRY:
	;	R0 = FIFO ID
	;ON RETURN:
	;	R0	= VALUE ON ENTRY
	;	C = 0 IF SUCCESS
	;		A = 0x00
	;	C = 1 IF FAIL
	;		A = ERROR CODE
	LFIFORESET	PROC
			;SAVE REGISTERS
			PUSH	B
			PUSH	DPL
			PUSH	DPH
			;GET FIFO'S FCB ADDRESS
			CALL	FIFOFCBADDR
			JNC		FIFORESETC
			;ERRROR - COULD NOT GET FIFO'S FCB ADDRESS
		FIFORESETA:
			SETB	C
		FIFORESETB:
			;RESTORE REGISTERS & RETURN
			POP		DPH
			POP		DPL
			POP		B
			RET
		FIFORESETC:
			;DISABLE INTERRUPTS
			PUSH	IE
			CLR		EA
			;LOAD ENTRY'S FLAGS
			MOV		B, #FIFO_ENTRY_OFFS_FLAGS
			CALL	DPTRBLRXDON
			;ENSURE FIFO IS NOT BUSY
			JNB		FIFO_BIT_BUSY, FIFORESETD
			POP		IE
			MOV		A, #FIFO_ERR_FIFO_BUSY
			SJMP	FIFORESETA
		FIFORESETD:
			;MARK FIFO AS BUSY, SET EMPTY FLAG, CLEAR FULL FLAG
			MOV		A, #(FIFO_FLAG_BUSY OR FIFO_FLAG_PRESENT OR FIFO_FLAG_EMPTY)
			CALL	DPTRBSRXDON
			;RESTORE INTERRUPT ENABLE
			POP		IE
			;ZEROIZE READ POINTER
			CLR		A
			MOV		B, #FIFO_ENTRY_OFFS_READ_INDEX
			CALL	DPTRBSRXDON
			;ZEROIZE WRITE POINTER
			MOV		B, #FIFO_ENTRY_OFFS_WRITE_INDEX
			CALL	DPTRBSRXDON
			;DISABLE INTERRUPTS
			PUSH	IE
			CLR		EA
			;CLEAR BUSY BIT
			MOV		B, #FIFO_ENTRY_OFFS_FLAGS
			CALL	DPTRBLRXDON
			CLR		FIFO_BIT_BUSY
			CALL	DPTRBSRXDON
			;RESTORE INTERRUPT ENABLE
			POP		IE
			CLR		A
			CLR		C
			SJMP	FIFORESETB
	ENDP


	;*RETURNS THE SIZE OF THE SPECIFIED FIFO
	;ON ENTRY:
	;	R0	= FIFO ID
	;ON RETURN:
	;	C	= 0 IF SUCCESS
	;		R1	= SIZE
	;	C	= 1 IF FAIL
	;		R1	= 0x00
	LFIFOSIZE	PROC
			;SAVE REGISTERS
			PUSH	DPL
			PUSH	DPH
			;GET FIFO'S FCB ADDRESS
			CALL	FIFOFCBADDR
			JNC		LFIFOSIZEB
			;ERROR - COULD NOT GET FIFO'S FCB ADDRESS
			MOV		R1, #0x00
		LFIFOSIZEA:
			POP		DPH
			POP		DPL
			RET
		LFIFOSIZEB:
			;SAVE ADDITIONAL REGISTERS
			PUSH	B
			;LOAD FIFO'S SIZE
			MOV		B, #FIFO_ENTRY_OFFS_SIZE
			CALL	DPTRBLRXDON
			MOV		R1, A
			CLR		C
			CLR		A
			;
			POP		B
			SJMP	LFIFOSIZEA
	ENDP


	;WRITES TO THE FIFO
	;ON ENTRY:
	;	R0		= FIFO ID
	;	R1		=	BYTE TO WRITE
	;ON RETURN:
	;	C	= 0 IF SUCCESS
	;		A	= 0x00
	;	C	= 1 IF ERROR
	;		A	= ERROR CODE
	FIFOWRITE	PROC
			;SAVE REGISTERS
			PUSH	B
			PUSH	DPL
			PUSH	DPH
			;GET FIFO'S FCB ADDRESS
			CALL	FIFOFCBADDR
			JNC		FIFOWRITEC
			;ERRROR - COULD NOT GET FIFO'S FCB ADDRESS
		FIFOWRITEA:
			SETB	C
		FIFOWRITEB:
			;RESTORE REGISTERS & RETURN
			POP		DPH
			POP		DPL
			POP		B
			RET
		FIFOWRITEC:
			;DISABLE INTERRUPTS
			PUSH	IE
			CLR		EA
			;LOAD ENTRY'S FLAGS
			MOV		B, #FIFO_ENTRY_OFFS_FLAGS
			CALL	DPTRBLRXDON
			;ENSURE FIFO IS NOT BUSY
			JNB		FIFO_BIT_BUSY, FIFOWRITEF
			POP		IE
			MOV		A, #FIFO_ERR_FIFO_BUSY
			SJMP	FIFOWRITEA
		FIFOWRITEF:
			;ENSURE FIFO IS NOT FULL
			JNB		FIFO_BIT_FULL, FIFOWRITEG
			POP		IE
			MOV		A, #FIFO_ERR_FIFO_FULL
			SJMP	FIFOWRITEA
		FIFOWRITEG:
			;MARK FIFO AS BUSY
			SETB	FIFO_BIT_BUSY
			CALL	DPTRBSRXDON
			;RESTORE INTERRUPT ENABLE
			POP		IE
			;SAVE FIFO ENTRY'S CSB ADDRESS
			PUSH	DPL
			PUSH	DPH
			;LOAD WRITE INDEX
			MOV		B, #FIFO_ENTRY_OFFS_WRITE_INDEX
			CALL	DPTRBLRXDON
			;LOAD BASE ADDRESS
			MOV		B, #FIFO_ENTRY_OFFS_BASE_ADDR_LSB
			CALL	DPTRWLDXDON
			;CALCULATE FIFO WRITE ADDRESS
			CALL	DPTRBADD
			;WRITE BYTE TO FIFO
			MOV		A, R1
			MOVX	@DPTR, A
			;RESTORE FIFO ENTRY'S CSB ADDRESS
			POP		DPH
			POP		DPL
			;INCREMENT WRITE INDEX
			MOV		B, #FIFO_ENTRY_OFFS_WRITE_INDEX
			CALL	DPTRBLRXDON
			INC		A
			PUSH	ACC
			;DETERMINE IF FIFO INDEX HAS WRAPPED AROUND
			MOV		B, #FIFO_ENTRY_OFFS_SIZE
			CALL	DPTRBLRXDON
			DEC		A
			POP		B
			CLR		C
			SUBB	A, B
			MOV		A, B
			JNC		FIFOWRITEH
			;ZEROIZE WRITE INDEX
			CLR		A
		FIFOWRITEH:
			;SAVE WRITE INDEX
			MOV		B, #FIFO_ENTRY_OFFS_WRITE_INDEX
			CALL	DPTRBSRXDON
			;DETERMINE IF FIFO FULL
			PUSH	ACC
			MOV		B, #FIFO_ENTRY_OFFS_READ_INDEX
			CALL	DPTRBLRXDON
			POP		B
			XRL		A, B
			MOV		B, #0x00
			JNZ		FIFOWRITEI
			;FIFO IS FULL
			MOV		B, #FIFO_FLAG_FULL
		FIFOWRITEI:
			PUSH	B
			;LOAD FIFO'S FLAGS
			MOV		B, #FIFO_ENTRY_OFFS_FLAGS
			CALL	DPTRBLRXDON
			;INSERT STATE OF FULL FLAG
			POP		B
			ORL		A, B
			;CLEAR FIFO'S EMPTY & BUSY FLAGS
			ANL		A, #((FIFO_FLAG_EMPTY XOR 0xFF) AND (FIFO_FLAG_BUSY XOR 0xFF))
			MOV		B, #FIFO_ENTRY_OFFS_FLAGS
			CALL	DPTRBSRXDON
			;
			CLR		A
			CLR		C
			;RESTORE REGISTERS & RETURN
			POP		DPH
			POP		DPL
			POP		B
			RET
	ENDP
		

	;*WRITES A BYTE TO THE SPECIFIED FIFO
	;ON ENTRY:
	;	R0	= FIFO ID
	;	R1	= BYTE
	;ON RETURN:
	;	R0	= VALUE ON ENTRY
	;	R1	= VALUE ON ENTRY
	;	C = 0 IF SUCCESS
	;		A = 0x00
	;	C = 1 IF FAIL
	;		A = ERROR CODE
	LFIFOWRITEBYTE	PROC
			CALL	FIFOWRITE
			RET
	ENDP


	;*WRITES A STRING TO THE SPECIFIED FIFO
	;WRITES AS MANY BYTES TO THE FIFO AS IT CAN BEFORE RETURNING WITH ERROR
	;ON ENTRY:
	;	R0		= FIFO ID
	;	R2:R1	= STRING POINTER
	;	R3		= TERMINATOR
	;ON RETURN:
	;	R0	= VALUE ON ENTRY
	;	C = 0 IF SUCCESS
	;		A = 0x00
	;		R2:R1	= ADDRESS OF STRING'S TERMINATOR
	;	C = 1 IF FAIL
	;		A = ERROR CODE
	;		R2:R1	= ADDRESS OF NEXT UNWRITTEN CHARACTER
	LFIFOWRITESTR	PROC
			;SAVE REGISTERS
			PUSH	B
			PUSH	DPL
			PUSH	DPH
			;
			MOV		DPL, R1
			MOV		DPH, R2
			MOV		B, R3
		LFIFOWRITESTRA:
			;LOAD STRING CHARACTER
			MOVX	A, @DPTR
			;WRITE CHARACTER TO FIFO
			MOV		R1, A
			CALL	FIFOWRITE
			JC		LFIFOWRITESTRB
			;CHARACTER == TERMINATOR
			MOV		A, R1
			CJNE	A, B, LFIFOWRITESTRC
			;DONE
			CLR		A
			CLR		C
		LFIFOWRITESTRB:
			;RESTORE REGISTERS & RETURN
			MOV		R1, DPL
			MOV		R2, DPH
			POP		DPH
			POP		DPL
			POP		B
			RET
		LFIFOWRITESTRC:
			;PROCESS NEXT CHARACTER
			INC		DPTR
			SJMP	LFIFOWRITESTRA
	ENDP

END
